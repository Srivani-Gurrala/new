<html>
    <head>

    </head>
    <body>
        Hello
        <script> 
// //         <!-- / callback
// //  ===================================
// // function greet(name, callback) {
// //   console.log('Hello, ' + name);
// //   callback(); 
// // }

// // function sayGoodbye() {
// //   alert('Goodbye!');
// // }


// // greet('Alice', sayGoodbye);
// // callback in asynchronous
// ============================================
// // function fetchData(callback) {
// //   console.log('Fetching data...');
// //   setTimeout(() => {
// //     console.log('Data fetched!');
// //     callback('Here is your data!');
// //   }, 2000); 
// // }

// // function handleData(data) {
// //   console.log('Processing:', data);
// // }

// // fetchData(handleData);
// // error handling
// ==============================================
// // function fetchData(callback) {
// //   const error = null; // No error
// //   const data = 'Here is your data!';

  
// //   if (!data) {
// //     callback('Error: No data available', null);
// //   } else {
// //     callback(null, data);
// //   }
// // }

// // function handleData(err, data) {
// //   if (err) {
// //     console.error('Something went wrong:', err);
// //     return;
// //   }
// //   console.log('Data received:', data);
// // }


// // fetchData(handleData);
// // promises
// =================================================
// // const myPromise = new Promise((resolve, reject) => {
// //        let success = true; 
// //    if (success) {
// //      resolve('Operation successful!'); 
// //    } else {
// //      reject('Something went wrong!');  
// //    }
// //  });

// // myPromise
// //   .then(result => console.log(result))   
// //   .catch(error => console.error(error));
// // error in promises*******
// // new Promise((resolve,reject) => {
// //     reject(new Error("Whoops!"));
// //     })
// //     .catch(alert);
// // promise.all
// =======================================================
// // Promise.all(iterable)     //syntax
// // Promise.all([
// //   new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
// //   new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
// //   new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
// // ]).then(alert);  // for resolved ones

// // promise.all for Errors
// ================================================
// // Promise.all([
// //   new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
// //   new Promise((resolve, reject) => setTimeout(() => reject(new Error("Whoops!")), 2000)),
// //   new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
// // ]).catch(alert);

// // promise.allsettled
// ==================================================
// // Each object has:

// // status: "fulfilled" if resolved, "rejected" if rejected.

// // value: The resolved value (if fulfilled).

// // reason: The rejection reason (if rejected).
// // const promises = [
// //   Promise.resolve(10),
// //   Promise.reject('Oops!'),
// //   Promise.resolve(20)
// // ];

// // Promise.allSettled(promises)
// //   .then(results => {
// //     console.log(results);
// //   });
// // promise.race
// =========================================
// // Promise.race([
// //   new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
// //   new Promise((resolve, reject) => setTimeout(() => reject(new Error("Whoops!")), 2000)),
// //   new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
// // ]).then(alert); 
// // promise.any
// =================================================
// //  AggregateError â€“ a special error object that stores all promise errors in its errors property.
// // Promise.any([
// //   new Promise((resolve, reject) => setTimeout(() => reject(new Error("Whoops!")), 1000)),
// //   new Promise((resolve, reject) => setTimeout(() => resolve(1), 2000)),
// //   new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
// // ]).then(alert); 
// // promisification
// =====================================================
// // one callback function converted tpo promise function
// // callback function
// // function getData(callback) {
// //   setTimeout(() => {
// //     callback(null, 'Data received!');
// //   }, 1000);
// // }

// // promisified version
// ======================================
// // function getDataPromisified() {
// //   return new Promise((resolve, reject) => {
// //     setTimeout(() => {
// //       resolve('Data received!');
// //       // Or, if there's an error:
// //       // reject('Something went wrong!');
// //     }, 1000);
// //   });
// // }

// // Microtasks
// ==============================================
// // current synchronous code finishes but before the browser processes other tasks like rendering or handling I/O operations.
// // console.log('Start');

// // Promise.resolve().then(() => {
// //   console.log('Microtask 1');
// // }).then(() => {
// //   console.log('Microtask 2');
// // });

// // console.log('End');

// // queueMicrotask()
// ====================================
// // explicitly adds a microtask, which runs right after the current synchronous code finishes.
// // console.log('Hello');

// // queueMicrotask(() => console.log('Microtask from queueMicrotask'));

// // console.log('World');

// // async/await
// =========================================
// // async- Declares a function as asynchronous.

// // Always returns a promise (even if you return a regular value, it gets wrapped in a promise).
// // await- Pauses the execution of the async function until the promise resolves or rejects.

// // Only works inside async functions.
// // function getData() {
// //   return new Promise((resolve) => {
// //     setTimeout(() => {
// //       resolve('Data received!');
// //     }, 1000);
// //   });
// // }

// // async function fetchData() {
// //   const data = await getData();
// //   console.log(data);
// // }

// // fetchData();

// // error handling in async/await
// =============================================
// // function getData() {
// //   return new Promise((_, reject) => {
// //     setTimeout(() => reject('Something went wrong!'), 1000);
// //   });
// // }

// // async function fetchData() {
// //   try {
// //     const data = await getData();
// //     console.log(data);
// //   } catch (error) {
// //     console.log(error);
// //   }
// // }

// // fetchData(); -->

</script>
</body>
</html>